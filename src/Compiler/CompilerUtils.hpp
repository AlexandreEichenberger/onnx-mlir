/*
 * SPDX-License-Identifier: Apache-2.0
 */

//===-------------------------- CompilerUtils.hpp -------------------------===//
//
// Copyright 2019-2024 The IBM Research Authors.
//
// =============================================================================
//
// Functions for adding passes and processing input files.
//
//===----------------------------------------------------------------------===//

#pragma once

#include "onnx-mlir/Compiler/OMCompilerTypes.h"

#include "mlir/IR/BuiltinOps.h"
#include "mlir/IR/OwningOpRef.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/Path.h"

#include <map>
#include <optional>
#include <set>
#include <string>
#include <vector>

namespace onnx_mlir {

struct Command {

  std::string _path;
  std::vector<std::string> _args;

  Command(std::string exePath)
      : _path(std::move(exePath)),
        _args({llvm::sys::path::filename(_path).str()}) {}

  Command &appendStr(const std::string &arg);
  Command &appendStrOpt(const std::optional<std::string> &arg);
  Command &appendList(const std::vector<std::string> &args);
  Command &resetArgs();
  int exec(std::string wdir = "") const;
};

// Registers and loads the mlir and onnx-mlir dialects needed to compile
// end to end. Initializes accelerator(s) if required.
void loadDialects(mlir::MLIRContext &context);

// ProcessInput* return 0 on success, OnnxMlirCompilerErrorCodes on error.
int processInputFile(llvm::StringRef inputFilename, mlir::MLIRContext &context,
    mlir::OwningOpRef<mlir::ModuleOp> &module, std::string *errorMessage);
int processInputArray(const void *onnxBuffer, int bufferSize,
    mlir::MLIRContext &context, mlir::OwningOpRef<mlir::ModuleOp> &module,
    std::string *errorMessage);

onnx_mlir::InputIRLevelType determineInputIRLevel(
    mlir::OwningOpRef<mlir::ModuleOp> &module);

// Returns 0 on success, OnnxMlirCompilerErrorCodes on failure.
int outputCode(mlir::OwningOpRef<mlir::ModuleOp> &module,
    std::string filenameWithExt, int64_t largeElementLimit = -1);

// Process the input model given by its module and context into an output file
// according to the emission target type. Name of the output file can be
// constructed using the getTargetFilename function below.  When  generating
// libraries or jar files, the compiler will link in lightweight runtimes / jar
// files. If these libraries / jar files are not in the system wide directory
// (typically /usr/local/lib), the user can override the default location using
// the ONNX_MLIR_LIBRARY_PATH environment variable.
// Returns 0 on success,OnnxMlirCompilerErrorCodes on failure.
int compileModule(mlir::OwningOpRef<mlir::ModuleOp> &module,
    mlir::MLIRContext &context, std::string outputNameNoExt,
    onnx_mlir::EmissionTargetType emissionTarget);

// Extend the input filename (with possibly a path but no extention) by the
// extention generated by the given emission target type. Names may be different
// depending on the underlying machine and/or operating system.
std::string getTargetFilename(
    const std::string filenameNoExt, EmissionTargetType target);

// Class that takes a list of comma separated regex expression to define a set
// of names that are "enabled" or not by a given compiler option. The
// "isEnabled(name)" function let a user determine if that name satisfies any of
// the regex or not. Class uses caching to reduce overheads.
//
// List of regex have the following properties.
// The presence of presence of "NONE" signifies that all names are disabled. The
// presence of "ALL" signifies that all names are enabled. A '.' char is treated
// as a regular char (aka "\."); and a '*' char is treated as a any string
// sequence (aka ".*").
class EnableByRegexOption {
public:
  EnableByRegexOption() = delete;
  // Constructor provides a string that is a comma separated list of regex.
  // These regex will determine which names are enabled or disabled by the
  // option. The emptyIsNone defines what to do when the provided string is
  // empty.
  EnableByRegexOption(
      bool emptyIsNone, std::string regexString = std::string());
  // Delayed initialization of the list of regex, permissible prior to a first
  // "isEnabled" query.
  void setRegexString(std::string regexString);

  // Returns true/false depending on wether that name matches any of the
  // regex.
  bool isEnabled(const std::string &name);
  bool isEnabled(const llvm::StringRef &name) { return isEnabled(name.str()); }

private:
  bool emptyIsNone; // If true, empty string is NONE; otherwise empty is ALL.
  bool allEnabled;  // Short-circuit test when all names are enabled.
  bool allDisabled; // Short-circuit test when all names are disabled.
  std::set<std::string> regexOfAllowedNames; // List of regex.
  std::map<std::string, bool> nameCache; // Map of name -> enabled/disabled.
};

} // namespace onnx_mlir
